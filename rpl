#!/usr/bin/env python3

import locale
import optparse
import os
import io
import re
try:
    import readline
except ImportError:
    pass
from stat import S_ISDIR, S_ISREG
import sys
import tempfile

from chardet.universaldetector import UniversalDetector


VERSION = "1.6.0"


# From: https://stackoverflow.com/questions/24528278/stream-multiple-files-into-a-readable-object-in-python
# Note: this code is licensed under CC-BY-SA 3.0, which is upwards-compatible
# with 4.0, and hence compatible with GPLv3.
def chain_streams(streams, buffer_size=io.DEFAULT_BUFFER_SIZE):
    """
    Chain an iterable of streams together into a single buffered stream.
    Usage:
        def generate_open_file_streams():
            for file in filenames:
                yield open(file, 'rb')
        f = chain_streams(generate_open_file_streams())
        f.read()
    """

    class ChainStream(io.RawIOBase):
        def __init__(self):
            self.leftover = b''
            self.stream_iter = iter(streams)
            try:
                self.stream = next(self.stream_iter)
            except StopIteration:
                self.stream = None

        def readable(self):
            return True

        def _read_next_chunk(self, max_length):
            # Return 0 or more bytes from the current stream, first returning all
            # leftover bytes. If the stream is closed returns b''
            if self.leftover:
                return self.leftover
            elif self.stream is not None:
                return self.stream.read(max_length)
            else:
                return b''

        def readinto(self, b):
            buffer_length = len(b)
            chunk = self._read_next_chunk(buffer_length)
            while len(chunk) == 0:
                # move to next stream
                if self.stream is not None:
                    self.stream.close()
                try:
                    self.stream = next(self.stream_iter)
                    chunk = self._read_next_chunk(buffer_length)
                except StopIteration:
                    # No more streams to chain together
                    self.stream = None
                    return 0  # indicate EOF
            output, self.leftover = chunk[:buffer_length], chunk[buffer_length:]
            b[:len(output)] = output
            return len(output)

    return io.BufferedReader(ChainStream(), buffer_size=buffer_size)


def show_license(*eat):
    print("""rpl - replace strings in files
Copyright (C) 2004-2005 Goran Weinholt <weinholt@debian.org>
Copyright (C) 2004 Christian Haggstrom <chm@c00.info>
Copyright (C) 2016 Kevin Coyner <kcoyner@debian.org>
Copyright (C) 2017 Jochen Kupperschmidt <homework@nwsnet.de>
Copyright (C) 2018-2019 Reuben Thomas <rrt@sc3d.org>

rpl comes with ABSOLUTELY NO WARRANTY.
You may redistribute copies of rpl under the terms of the
GNU General Public License.
For more information about these matters, see the file named COPYING.""")
    sys.exit(0)


def warn(message):
    print("\nrpl: {}".format(message), file=sys.stderr)

def get_files(filenames, recurse, suffixen, verbose, hidden_files):
    """Yield (filename, permissions) pairs."""
    for filename in filenames:
        try:
            perms = os.lstat(filename)
        except OSError as e:
            warn("SKIPPING {}: unable to read permissions; error: {}".format(filename, e))
            continue

        if S_ISDIR(perms.st_mode):
            if recurse:
                if verbose:
                    warn("Scanning directory: {}".format(filename))

                for f in os.listdir(filename):
                    if not hidden_files and f.startswith('.'):
                        if verbose:
                            warn("SKIPPING: {} (hidden)".format(
                                os.path.join(filename, f))
                            )
                        continue

                    yield from get_files([os.path.join(filename, f)],
                                         recurse, suffixen, verbose, hidden_files)
            else:
                if verbose:
                    warn("SKIPPING directory {}".format(filename))
                continue
        elif S_ISREG(perms.st_mode):
            if suffixen and not any(filename.endswith(s) for s in suffixen):
                warn("SKIPPING: {} (suffix not in list)".format(filename))
                continue

            yield filename, perms
        else:
            warn("SKIPPING: {} (not a regular file)".format(filename))


def unescape(s):
    regex = re.compile(r'\\([0-7]{1,3}|x[0-9a-fA-F]{2}|[nrtvafb\\])')
    return regex.sub(lambda match: eval('"%s"' % match.group()), s)

def casetype(string):
    # Starts with lower case
    case = 0

    # Capitalized?
    if len(string) >= 1 and string[0].isupper():
        case = 1

        # All upper case?
        all_upper = True
        for i in range(1, len(string)):
            if not string[i].isupper():
                all_upper = False
                break
        if all_upper:
            case = 2

    return case

def caselike(model, string):
    if len(string) > 0:
        case = casetype(model)
        if case == 1:
            string = string[0].upper() + string[1:]
        elif case == 2:
            string = string.upper()
    return string

def replace(instream, outstream, regex, before, after, encoding):
    patlen = len(before)
    sum = 0

    tonext = u''
    while True:
        block = instream.read(io.DEFAULT_BUFFER_SIZE)
        if len(block) == 0:
            break

        block = block.decode(encoding=encoding)
        parts = regex.split(tonext + block)
        sum += len(parts) // 2
        lastpart = parts[-1]
        if lastpart:
            tonext = lastpart[-patlen:]
            parts[-1] = lastpart[:-len(tonext)]
        else:
            tonext = u''

        for i in range(1, len(parts), 2):
            if parts[i] != '':
                replace = after
                if regex.flags & re.I != 0:
                    replace = caselike(parts[i], after)
                parts[i] = replace

        joined_parts = ''.join(parts)
        outstream.write(joined_parts.encode(encoding=encoding))

    outstream.write(tonext.encode(encoding=encoding))

    return sum


def create_cli_args_parser():
    """Create command line argument parser."""
    usage = "usage: %prog [options] old_string new_string target_file(s)"
    parser = optparse.OptionParser(usage, version="%prog " + VERSION)

    parser.add_option("-L", "--license",
                      action="callback",
                      callback=show_license,
                      help="show the software license")

    parser.add_option("--encoding",
                      action="store",
                      dest="encoding",
                      default=None,
                      help="specify character set encoding")
    parser.add_option("-x",
                      metavar="SUFFIX",
                      action="append",
                      dest="suffixen",
                      default=[],
                      help="specify file suffix to match")

    parser.add_option("-i", "--ignore-case",
                      action="store_true",
                      dest="ignore_case",
                      default=False,
                      help="do a case insensitive match")

    parser.add_option("-w", "--whole-words",
                      action="store_true",
                      dest="whole_words",
                      default=False,
                      help="whole words (old_string matches on word boundaries only)")

    parser.add_option("-b", "--backup",
                      action="store_true",
                      dest="do_backup",
                      default=False,
                      help="make a backup before overwriting files")

    parser.add_option("-q", "--quiet",
                      action="store_true",
                      dest="quiet",
                      default=False,
                      help="quiet mode")

    parser.add_option("-v", "--verbose",
                      action="store_true",
                      dest="verbose",
                      default=False,
                      help="verbose mode")

    parser.add_option("-s", "--dry-run",
                      action="store_true",
                      dest="dry_run",
                      default=False,
                      help="simulation mode")

    parser.add_option("-R", "--recursive",
                      action="store_true",
                      dest="recurse",
                      default=False,
                      help="recurse into subdirectories")

    parser.add_option("-e", "--escape",
                      action="store_true",
                      dest="escapes",
                      default=False,
                      help="expand escapes in old_string and new_string")

    parser.add_option("-p", "--prompt",
                      action="store_true",
                      dest="prompt",
                      default=False,
                      help="prompt before modifying each file")

    parser.add_option("-f", "--force",
                      action="store_true",
                      dest="force",
                      default=False,
                      help="ignore errors when trying to preserve permissions")

    parser.add_option("-d", "--keep-times",
                      action="store_true",
                      dest="keep_times",
                      default=False,
                      help="keep the modification times on modified files")

    parser.add_option("-a", "--all",
                      action="store_true",
                      dest="hidden_files",
                      default=False,
                      help="do not ignore files and directories starting with .")

    return parser


def parse_cli_args():
    """Parse command line arguments."""
    parser = create_cli_args_parser()
    opts, args = parser.parse_args()

    # args should now contain old_str, new_str and a list of files/dirs
    if len(args) < 3:
        parser.error("must have at least three arguments")
    if args[0] == "":
        parser.error("must have something to replace")

    return opts, args


def main():
    global opts
    opts, args = parse_cli_args()

    old_str = args[0]
    new_str = args[1]
    files = args[2:]

    # See if all the files actually exist
    for file in files:
        if not os.path.exists(file):
            warn("File \"{}\" not found".format(file))
            sys.exit(os.EX_DATAERR)

    if new_str == "" and not opts.quiet:
        print("Really DELETE all occurrences of {} ({})? (Y/[N]) ".format(
            old_str,
            "ignoring case" if opts.ignore.case else "case sensitive"
        ), file=sys.stderr, end='')

        line = input()
        if line != "" and line[0] in "nN":
            warn("User cancelled operation.")
            sys.exit(os.EX_TEMPFAIL)

    # Tell the user what is going to happen
    warn("{} \"{}\" with \"{}\" ({}; {})".format(
        "Simulating replacement of" if opts.dry_run else "Replacing",
        old_str,
        new_str,
        "ignoring case" if opts.ignore_case else "case sensitive",
        "whole words only" if opts.whole_words else "partial words matched",
    ))

    if opts.dry_run and not opts.quiet:
        warn("The files listed below would be modified in a replace operation")

    encoding = None
    if opts.encoding:
        encoding = opts.encoding

    if opts.escapes:
        old_str = unescape(old_str)
        new_str = unescape(new_str)

    regex_str = re.escape(old_str)
    if opts.whole_words:
        regex_str = r"\b" + regex_str + r"\b"
    regex = re.compile(r"(" + regex_str + r")", re.I if opts.ignore_case else 0)

    total_files = 0
    total_matches = 0
    files = get_files(files, opts.recurse, opts.suffixen, opts.verbose, opts.hidden_files)
    for filename, perms in files:
        total_files += 1

        # Open the input file
        try:
            f = open(filename, "rb")
        except IOError as e:
            warn("SKIPPING {}: cannot open for reading; error: {}".format(filename, e))
            continue

        # Create the output file
        try:
            o, tmp_path = tempfile.mkstemp("", ".tmp.")
            o = os.fdopen(o, "wb")
        except OSError as e:
            warn("SKIPPING {}: cannot create temp file; error: {}".format(filename, e))
            continue

        # Set permissions and owner
        try:
            os.chown(tmp_path, perms.st_uid, perms.st_gid)
            os.chmod(tmp_path, perms.st_mode)
        except OSError as e:
            warn("Unable to set owner/group/perms of {}; error: {}".format(filename, e))
            if opts.force:
                warn("WARNING: New owner/group/perms may not match!\n")
            else:
                warn("SKIPPING {}!\n".format(filename))
                os.unlink(tmp_path)
                continue

        if opts.verbose and not opts.dry_run:
            warn("Processing: {}".format(filename))
        elif not opts.quiet and not opts.dry_run:
            print(".", file=sys.stderr, flush=True, end='')

        # If we don't have an explicit encoding, guess
        block = b''
        if encoding is None:
            detector = UniversalDetector()
            while True:
                next_block = f.read(io.DEFAULT_BUFFER_SIZE)
                if len(next_block) == 0: break
                block += next_block
                detector.feed(next_block)
                if detector.done: break
            f = chain_streams([io.BytesIO(block), f])

            detector.close()
            if detector.done:
                encoding = detector.result['encoding']
                if opts.verbose:
                    warn("guessed encoding '{}'".format(encoding))
                else:
                    encoding = locale.getpreferredencoding(False)
                    warn("could not guess encoding; using locale default '{}'".format(encoding))

        # Do the actual work now
        matches = replace(f, o, regex, old_str, new_str, encoding)

        f.close()
        o.close()

        if matches == 0:
            os.unlink(tmp_path)
            continue

        if opts.dry_run:
            try:
                fn = os.path.realpath(filename)
            except OSError as e:
                fn = filename

            if not opts.quiet:
                print("  {}".format(fn), file=sys.stderr)

            os.unlink(tmp_path)
            total_matches += matches
            continue

        if opts.prompt:
            print("\nSave \"{}\"? ([Y]/N) ".format(filename), file=sys.stderr, end='')

            line = ""
            while line == "" or line[0] not in "Yy\nnN":
                line = input()

            if line[0] in "nN":
                print("Not saved", file=sys.stderr)
                os.unlink(tmp_path)
                continue

            print("Saved", file=sys.stderr)

        if opts.do_backup:
            try:
                os.rename(filename, filename + "~")
            except OSError as e:
                warn("Error renaming {} to {}:".format(filename, filename + "~", e))
                continue

        # Rename the file
        try:
            os.rename(tmp_path, filename)
        except OSError as e:
            warn("Could not replace {} with {}; error: {}".format(tmp_path, filename, e))
            os.unlink(tmp_path)
            continue

        # Restore the times
        if opts.keep_times:
            try:
                os.utime(filename, (perms.st_atime, perms.st_mtime))
            except OSError as e:
                warn("Error setting timestamps of {}: {}".format(filename, e))

        total_matches += matches

    # We're about to exit, give a summary
    if not opts.quiet:
        warn("A total of {} matches {} in {} file{} searched".format(
            total_matches,
            "found" if opts.dry_run else "replaced",
            total_files,
            "s" if total_files != 1 else "",
        ))
        if opts.dry_run:
            warn("None replaced (simulation mode)")


if __name__ == "__main__":
    main()
